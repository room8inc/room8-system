# Room8 認証・ログイン・チェックイン

## 🎯 基本方針

**通常ログイン（メイン） + セッション30日間保持**

- **メイン**: メール+パスワードでログイン（ブックマークに保存しておく）
- **セッション**: 30日間自動ログイン維持
- **チェックイン**: 事前ログイン + 会場ではQRのみ

---

## 📋 ログイン方法の選択肢

### 選択肢1: ログイン状態を長期間保持（採用）

**方法：**
- ログイン時に「ログイン状態を保持」チェックボックスを表示
- チェックした場合、30日間自動ログイン（パスワード再入力不要）
- 次回からアプリを開けば自動的にログイン済み

**メリット：**
- ✅ 実装が簡単
- ✅ 既存のパスワード認証をそのまま活用できる
- ✅ スマホでもPCでも同じ方法で使える
- ✅ 追加のデバイス不要

**デメリット：**
- ❌ 初回はメールアドレス + パスワード入力が必要
- ❌ 30日経つと再度ログインが必要
- ❌ パスワードを忘れた場合の対応が必要

**必要なもの：**
- セッション管理機能（標準的）
- 追加コスト：ほぼなし

---

### 選択肢2: QRコードログイン + ログイン状態保持

**方法：**
- 会員登録時に個人用QRコードを発行（スマホに保存）
- ログイン画面でQRコードを読み取る（パスワード不要）
- ログイン状態を30日間保持
- 次回からアプリを開けば自動的にログイン済み

**メリット：**
- ✅ パスワード入力不要（初回もQRコードのみ）
- ✅ チェックイン/チェックアウトと同じQRコード方式で統一感
- ✅ パスワード忘れの心配がない

**デメリット：**
- ❌ 実装がやや複雑（QRコード生成・読み取り機能が必要）
- ❌ QRコードが漏洩した場合のセキュリティ対策が必要
- ❌ 個人用QRコードの管理機能が必要

**必要なもの：**
- QRコード生成機能
- QRコード読み取り機能（カメラAPI）
- セッション管理機能
- 追加コスト：ほぼなし（QRコードライブラリは無料）

---

### その他の選択肢（参考）

- **メールリンクログイン**（パスワードレス）：メールアドレスのみ入力、メールリンクでログイン
- **生体認証**（Face ID/Touch ID）：WebAuthn APIが必要、スマホのみ
- **SNSログイン**（Google、Apple）：OAuth実装が必要

---

## ✅ 決定事項：通常ログイン（メイン）

### 採用：ログイン状態を長期間保持

**実装方針：**
- ログイン時に「ログイン状態を保持」チェックボックスを表示
- チェックした場合、30日間（または長期間）自動ログイン維持
- パスワード保存機能（ブラウザの機能）も活用可能

**フロー：**
```
【事前（自宅やオフィス）】
1. アプリでログイン
2. 「ログイン状態を保持」にチェック（30日間維持）
3. パスワード保存機能も利用可能

【会場に来たら】
1. アプリを開く（既にログイン済み）
2. 会場のQRコードを読む
3. チェックイン完了（すぐに）
```

---

## 📱 チェックインフロー

### 基本認識

**会場のQRコードを読み込んでチェックインする**

### 採用：事前ログイン + 会場ではQRのみ

**決定理由：**
- セッション時間を長めに設定（30日間など）
- パスワード保存機能（ブラウザの機能）を活用
- 会場での操作が最も簡単（QRコードを読むだけ）

**ログイン方法：**
- **メイン**: メール+パスワードでログイン（ブックマークに保存しておく）
- **オプション**: LINE連携（Phase 2で追加、なくても使える）

**実装方針：**
1. ログイン時に「ログイン状態を保持」チェックボックスを表示
2. チェックした場合、30日間（または長期間）自動ログイン維持
3. パスワード保存機能（ブラウザの機能）も活用可能
4. 会場では既にログイン済み状態なので、QRコードを読むだけ

**フロー：**
```
【事前（自宅やオフィス）】
1. アプリでログイン
2. 「ログイン状態を保持」にチェック（30日間維持）
3. パスワード保存機能も利用可能

【会場に来たら】
1. アプリを開く（既にログイン済み）
2. 会場のQRコードを読む
3. チェックイン完了（すぐに）
```

**フォールバック：**
- ログイン状態が切れた場合のみ、会場でログイン画面を表示
- パスワード保存機能があれば、簡単に再ログイン可能

---

## 🔐 QRコード設計

### QRコードの種類と役割

#### 1. 会場のQRコード（入退室用）

**内容：**
- **会場ID**: 例「room8-venue-001」
- **タイプ**: 静的なQRコード（変更不要）
- **個人情報**: 含まれない（誰でも読める）

**用途：**
- チェックイン/チェックアウト時に会場を識別

**個人識別の方法：**
**会場のQRコードだけでは個人を識別できない**

**個人識別の仕組み:**
1. アプリで会場のQRコードを読み取る
2. ログイン状態（セッション）からユーザーIDを自動取得
3. 会場ID（QRコード）+ ユーザーID（セッション）で個人を識別

**処理フロー（詳細版）:**
```
[クライアント側（端末・ブラウザ）]
  ↓
ユーザーが会場のQRコードを読み取る
  ↓
会場ID取得: "room8-venue-001"（QRコードから）
  ↓
チェックインAPIを呼び出す
  - 会場ID: "room8-venue-001"
  - セッショントークン: "session-token-xyz"（Cookieやヘッダーに自動付与）
  ↓
[サーバー側]
  ↓
セッショントークンを検証
  ↓
サーバー側のセッションストレージからユーザーIDを取得
  - セッショントークン → ユーザーID: "user-12345"
  ↓
チェックイン実行
  - 会場ID: "room8-venue-001"（リクエストから）
  - ユーザーID: "user-12345"（サーバー側のセッションから）
  - 時刻: 2025-11-01 10:00:00
  ↓
データベースに記録
```

---

#### 2. 個人用QRコード（ログイン用・オプション）

**内容：**
- **ユーザーID**: 例「user-12345」
- **トークン**: 認証用トークン（例：JWT）
- **タイプ**: 動的なQRコード（定期的に更新）
- **個人情報**: ユーザーIDが含まれる（個人識別可能）

**用途：**
- ログイン認証（初回のみ、またはログイン状態が切れた時）

**個人識別の方法：**
**個人用QRコードにユーザーIDが含まれるため、QRコードから直接個人を識別可能**

---

#### 3. 会議室QRコード

**内容：**
- **会議室ID**: 例「room8-meetingroom-001」
- **タイプ**: 静的なQRコード（変更不要）
- **個人情報**: 含まれない（誰でも読める）

**用途：**
- 会議室利用開始/終了時に会議室を識別

**個人識別の方法：**
**会場QRコードと同じ仕組み**
1. 会議室QRコードを読み取る
2. ログインセッションからユーザーIDを自動取得
3. 会議室ID（QRコード）+ ユーザーID（セッション）で個人を識別

---

## 🔐 セッション管理・個人識別の仕組み

### 重要なポイント

**ユーザーIDはサーバー側で管理され、端末（クライアント）から送信されるのではなく、サーバー側のセッションから取得します。**

---

### 端末（クライアント側）に保存されるもの

**保存される情報：**
- **セッショントークン**: 認証用のトークン（例：「session-token-xyz」）
  - Cookieに保存（HttpOnly Cookie推奨）
  - またはLocalStorageに保存（非推奨、XSSリスク）

**保存されない情報：**
- ❌ **ユーザーIDは保存しない**（セキュリティのため）
- ❌ **パスワードは保存しない**（当然）

**セッショントークンの役割：**
- サーバー側でユーザーを識別するための鍵
- ユーザーIDそのものではない
- トークンからユーザーIDを逆引きできない（サーバー側のみ可能）

---

### サーバー側に保存されるもの

**重要なポイント:**
- **ユーザー情報テーブル（usersテーブル）にはセッション情報を保存しない**
- **セッションストレージ（sessionsテーブル）に「セッショントークン → ユーザーID」のマッピングを保存**
- セッショントークンはユーザー情報に保存するのではなく、独立したセッションストレージに保存

**データベース設計の例:**
```sql
-- ユーザー情報テーブル（既存）
users テーブル
- user_id: "user-12345" (主キー)
- email: "user@example.com"
- name: "山田太郎"
- created_at: "2025-10-01 10:00:00"
-- セッション情報は含まれない

-- セッションストレージ（新規テーブル）
sessions テーブル
- session_token: "session-token-xyz" (主キー)
- user_id: "user-12345" (外部キー → users.user_id を参照)
- expires_at: "2025-12-01 10:00:00"
- created_at: "2025-11-01 10:00:00"

-- リレーション
sessions.user_id → users.user_id
```

**重要なポイント:**
- `sessions`テーブルは**独立したテーブル**
- `users`テーブルには**セッション情報は保存しない**
- `sessions`テーブルの`user_id`は`users`テーブルへの**参照（外部キー）**
- セッショントークンからユーザーIDを取得し、そのユーザーIDで`users`テーブルからユーザー情報を取得

---

### 個人識別のフロー（詳細）

#### ステップ1: ログイン時

```
[クライアント側（端末）]
  ↓
メール+パスワードでログイン
  ↓
ログインAPIを呼び出す
  - メールアドレス + パスワード
  ↓
[サーバー側]
  ↓
ユーザー認証
  ↓
ユーザーIDを確認（例：「user-12345」）
  ↓
セッショントークンを生成（例：「session-token-xyz」）
  ↓
サーバー側のセッションストレージに保存
  {
    "session-token-xyz": {
      userId: "user-12345",
      expiresAt: "2025-12-01 10:00:00"
    }
  }
  ↓
クライアントにセッショントークンを返す
  - Cookieに設定（HttpOnly Cookie推奨）
  - またはレスポンスボディで返す
  ↓
[クライアント側（端末）]
  ↓
セッショントークンを保存（Cookieに自動保存）
  - Cookie名: "sessionToken"
  - 値: "session-token-xyz"
```

#### ステップ2: チェックイン/チェックアウト時

```
[クライアント側（端末）]
  ↓
会場のQRコードを読み取る
  ↓
会場ID取得: "room8-venue-001"
  ↓
チェックインAPIを呼び出す
  POST /api/checkin
  - Body: { venueId: "room8-venue-001" }
  - Cookie: sessionToken="session-token-xyz"（自動で送信）
  ↓
[サーバー側]
  ↓
リクエストからセッショントークンを取得
  - Cookieから取得: "session-token-xyz"
  - またはAuthorizationヘッダーから取得
  ↓
セッショントークンを検証
  - セッションストレージを検索
  - 有効期限を確認
  ↓
サーバー側のセッションストレージからユーザーIDを取得
  "session-token-xyz" → userId: "user-12345"
  ↓
チェックイン実行
  - 会場ID: "room8-venue-001"（リクエストから）
  - ユーザーID: "user-12345"（サーバー側のセッションから）
  - 時刻: 2025-11-01 10:00:00
  ↓
データベースに記録
```

---

### サーバー側の実装例（Node.js + Express）

```javascript
// セッション管理ミドルウェア
const authenticateUser = async (req, res, next) => {
  // 1. リクエストからセッショントークンを取得
  const sessionToken = req.cookies.sessionToken 
    || req.headers.authorization?.replace('Bearer ', '');
  
  if (!sessionToken) {
    return res.status(401).json({ error: '認証が必要です' });
  }
  
  // 2. セッションストレージ（sessionsテーブル）から検索
  const session = await db.query(
    'SELECT user_id, expires_at FROM sessions WHERE session_token = ?',
    [sessionToken]
  );
  
  if (!session || session.expires_at < new Date()) {
    return res.status(401).json({ error: 'セッションが無効です' });
  }
  
  // 3. セッションからユーザーIDを取得（sessionsテーブルから取得）
  req.userId = session.user_id; // "user-12345"
  
  next();
};

// チェックインAPI
app.post('/api/checkin', authenticateUser, async (req, res) => {
  const venueId = req.body.venueId; // リクエストから
  const userId = req.userId; // サーバー側のセッションから取得
  
  // チェックイン実行
  await checkIn({
    venueId: venueId,
    userId: userId,
    timestamp: new Date()
  });
  
  res.json({ success: true });
});
```

---

## 🔐 セキュリティ考慮事項

### セッショントークンのセキュリティ

**HttpOnly Cookieの重要性：**
```javascript
// セキュアなCookie設定
res.cookie('sessionToken', sessionToken, {
  httpOnly: true,  // JavaScriptからアクセス不可（XSS攻撃対策）
  secure: true,    // HTTPSのみ送信（中間者攻撃対策）
  sameSite: 'strict', // CSRF攻撃対策
  maxAge: 30 * 24 * 60 * 60 * 1000 // 30日
});
```

**メリット:**
- XSS攻撃（JavaScriptによるCookie窃取）を防ぐ
- ブラウザが自動的にCookieを送信（開発者が意識する必要がない）

### QRコードのセキュリティ

**会場QRコードのセキュリティ:**
- 会場QRコードは誰でも読める（個人情報なし）
- 会場QRコードを読み取っただけでは個人を識別できない
- **対策**: ログイン状態（セッション）が必須

**個人用QRコードのセキュリティ（オプション）:**
- 個人用QRコードにユーザーIDが含まれる
- QRコードが漏洩した場合のリスク
- **対策**: 
  - トークンの有効期限（例：5分）
  - 定期的な更新（例：1ヶ月ごと）
  - ユーザーが無効化可能

---

## ✅ まとめ

### 個人識別の仕組み

1. **会場のQRコード読み取り時**
   - 会場QRコード → 会場ID取得
   - ログインセッション → ユーザーID取得（自動）
   - **会場ID + ユーザーID** で個人を識別

2. **ログイン時**
   - メール+パスワードで認証
   - セッショントークンを生成
   - サーバー側のセッションストレージに保存（sessionsテーブル）

### 重要なポイント

- ✅ **会場のQRコードだけでは個人を識別できない** → セッションと組み合わせる
- ✅ **ユーザーIDはサーバー側のセッションから取得**（端末から送信されない）
- ✅ **セッション情報は独立したテーブルに保存**（usersテーブルとは分離）
- ✅ **セキュリティ**: ログイン状態（セッション）が必須
- ✅ **QRコードを二回読む必要はない** → 会場のQRコード一度だけ

